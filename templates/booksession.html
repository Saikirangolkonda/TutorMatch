from flask import Flask, render_template, request, redirect, url_for, jsonify, abort
from datetime import datetime, timedelta
import os, json, uuid, boto3
from botocore.exceptions import ClientError
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'your-secret-key-change-in-production')

# AWS Configuration
AWS_REGION = os.environ.get('AWS_REGION', 'ap-south-1')  # Mumbai region
SNS_TOPIC_ARN = os.environ.get('SNS_TOPIC_ARN', 'arn:aws:sns:ap-south-1:686255965861:TutorMatchNotifications')

# Initialize AWS clients
try:
    dynamodb = boto3.resource('dynamodb', region_name=AWS_REGION)
    sns_client = boto3.client('sns', region_name=AWS_REGION)
    
    # DynamoDB Tables
    users_table = dynamodb.Table('Users')
    tutors_table = dynamodb.Table('Tutors')
    bookings_table = dynamodb.Table('Bookings')
    payments_table = dynamodb.Table('Payments')
    sessions_table = dynamodb.Table('Sessions')
    
    logger.info("AWS services initialized successfully")
except Exception as e:
    logger.error(f"Failed to initialize AWS services: {str(e)}")
    # Fallback to local development
    dynamodb = None
    sns_client = None

# Initialize default tutor data in DynamoDB
def initialize_tutors():
    """Initialize default tutors in DynamoDB if they don't exist"""
    if not dynamodb:
        return
    
    default_tutors = [
        {
            "tutor_id": "tutor1",
            "name": "John Smith",
            "subjects": ["Mathematics", "Physics"],
            "rate": 30,
            "rating": 4.8,
            "bio": "Experienced math and physics tutor with 5+ years of teaching experience.",
            "availability": ["Monday 9-17", "Wednesday 9-17", "Friday 9-17"],
            "email": "john.smith@tutormatch.com",
            "phone": "+91-9876543210",
            "created_at": datetime.now().isoformat()
        },
        {
            "tutor_id": "tutor2",
            "name": "Sarah Johnson",
            "subjects": ["English", "Literature"],
            "rate": 25,
            "rating": 4.6,
            "bio": "English literature specialist, helping students excel in writing and analysis.",
            "availability": ["Tuesday 10-18", "Thursday 10-18", "Saturday 9-15"],
            "email": "sarah.johnson@tutormatch.com",
            "phone": "+91-9876543211",
            "created_at": datetime.now().isoformat()
        }
    ]
    
    try:
        for tutor in default_tutors:
            tutors_table.put_item(
                Item=tutor,
                ConditionExpression='attribute_not_exists(tutor_id)'
            )
        logger.info("Default tutors initialized in DynamoDB")
    except ClientError as e:
        if e.response['Error']['Code'] != 'ConditionalCheckFailedException':
            logger.error(f"Error initializing tutors: {str(e)}")

# Initialize tutors on startup
if dynamodb:
    initialize_tutors()

def send_notification(email, subject, message, notification_type="general"):
    """Send email notification via SNS"""
    if not sns_client:
        logger.warning("SNS client not available, skipping notification")
        return False
    
    try:
        # Create message with email-specific formatting
        sns_message = {
            "default": message,
            "email": f"Subject: {subject}\n\n{message}"
        }
        
        # Publish to SNS topic
        response = sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Message=json.dumps(sns_message),
            Subject=subject,
            MessageStructure='json'
        )
        
        logger.info(f"Notification sent successfully. MessageId: {response['MessageId']}")
        return True
    except ClientError as e:
        logger.error(f"Failed to send notification: {str(e)}")
        return False

def get_all_tutors():
    """Get all tutors from DynamoDB"""
    if not dynamodb:
        # Fallback data for local development
        return {
            "tutor1": {
                "name": "John Smith",
                "subjects": ["Mathematics", "Physics"],
                "rate": 30,
                "rating": 4.8,
                "bio": "Experienced math and physics tutor with 5+ years of teaching experience.",
                "availability": ["Monday 9-17", "Wednesday 9-17", "Friday 9-17"]
            },
            "tutor2": {
                "name": "Sarah Johnson",
                "subjects": ["English", "Literature"],
                "rate": 25,
                "rating": 4.6,
                "bio": "English literature specialist, helping students excel in writing and analysis.",
                "availability": ["Tuesday 10-18", "Thursday 10-18", "Saturday 9-15"]
            }
        }
    
    try:
        response = tutors_table.scan()
        tutors = {}
        for item in response['Items']:
            tutors[item['tutor_id']] = item
        return tutors
    except ClientError as e:
        logger.error(f"Error fetching tutors: {str(e)}")
        return {}

def get_tutor(tutor_id):
    """Get specific tutor from DynamoDB"""
    if not dynamodb:
        all_tutors = get_all_tutors()
        return all_tutors.get(tutor_id)
    
    try:
        response = tutors_table.get_item(Key={'tutor_id': tutor_id})
        return response.get('Item')
    except ClientError as e:
        logger.error(f"Error fetching tutor {tutor_id}: {str(e)}")
        return None

@app.route('/')
def homepage():
    try:
        return render_template("homepage.html")
    except:
        return """
        <h1>Welcome to TutorMatch</h1>
        <p>Find the perfect tutor for your learning needs!</p>
        <a href='/login'>Login</a> | <a href='/register'>Register</a>
        """

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        
        if dynamodb:
            try:
                response = users_table.get_item(Key={'email': email})
                user = response.get('Item')
                if user and user['password'] == password:
                    return redirect(url_for('student_dashboard'))
            except ClientError as e:
                logger.error(f"Login error: {str(e)}")
        
        return "Invalid credentials", 401
    
    try:
        return render_template('login.html')
    except:
        return '''
            <h1>Login</h1>
            <form method="post">
            Email: <input name="email" type="email" required><br><br>
            Password: <input name="password" type="password" required><br><br>
            <button type="submit">Login</button>
            </form>
            <p><a href="/register">Don't have an account? Register here</a></p>
        '''

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        name = request.form['name']
        
        if dynamodb:
            try:
                # Check if user already exists
                response = users_table.get_item(Key={'email': email})
                if response.get('Item'):
                    return "User already exists", 400
                
                # Create new user
                users_table.put_item(Item={
                    'email': email,
                    'password': password,
                    'name': name,
                    'created_at': datetime.now().isoformat()
                })
                
                # Send welcome notification
                welcome_message = f"Welcome to TutorMatch, {name}! Your account has been created successfully. You can now search for tutors and book sessions."
                send_notification(email, "Welcome to TutorMatch!", welcome_message, "welcome")
                
                return redirect(url_for('login'))
            except ClientError as e:
                logger.error(f"Registration error: {str(e)}")
                return "Registration failed. Please try again.", 500
        
        return redirect(url_for('login'))
    
    try:
        return render_template('register.html')
    except:
        return '''
            <h1>Register</h1>
            <form method="post">
            Name: <input name="name" required><br><br>
            Email: <input name="email" type="email" required><br><br>
            Password: <input name="password" type="password" required><br><br>
            <button type="submit">Register</button>
            </form>
            <p><a href="/login">Already have an account? Login here</a></p>
        '''

@app.route('/student-dashboard')
def student_dashboard():
    try:
        return render_template("student_dashboard.html")
    except:
        return '''
        <h1>Student Dashboard</h1>
        <nav>
            <a href="/tutor-search">Search Tutors</a> |
            <a href="/api/student-data">My Bookings</a> |
            <a href="/logout">Logout</a>
        </nav>
        '''

@app.route('/tutor-search')
def tutor_search():
    tutors_data = get_all_tutors()
    try:
        return render_template("tutor_search.html", tutors_with_id=[{"id": k, **v} for k, v in tutors_data.items()])
    except:
        html = "<h1>Find Tutors</h1>"
        for tid, t in tutors_data.items():
            html += f"""
            <div style="border: 1px solid #ccc; padding: 10px; margin: 10px;">
                <h3>{t['name']}</h3>
                <p>Subjects: {', '.join(t.get('subjects', []))}</p>
                <p>Rate: ${t.get('rate', 25)}/hour</p>
                <p>Rating: {t.get('rating', 0)}/5</p>
                <a href='/tutor-profile/{tid}'>View Profile</a>
            </div>
            """
        return html

@app.route('/tutor-profile/<tutor_id>')
def tutor_profile(tutor_id):
    tutor = get_tutor(tutor_id)
    if not tutor:
        abort(404)
    try:
        return render_template("tutor_profile.html", tutor=tutor, tutor_id=tutor_id)
    except:
        return f"""
        <h1>{tutor['name']}</h1>
        <p>Subjects: {', '.join(tutor.get('subjects', []))}</p>
        <p>Rate: ${tutor.get('rate', 25)}/hour</p>
        <p>Rating: {tutor.get('rating', 0)}/5</p>
        <p>Bio: {tutor.get('bio', 'No bio available')}</p>
        <a href='/book-session/{tutor_id}'>Book Session</a>
        """

@app.route('/book-session/<tutor_id>', methods=['GET', 'POST'])
def book_session(tutor_id):
    tutor = get_tutor(tutor_id)
    if not tutor:
        abort(404)
    
    if request.method == 'POST':
        booking_id = str(uuid.uuid4())
        date = request.form['date']
        time = request.form['time']
        subject = request.form['subject']
        session_type = request.form.get('session_type', 'Single Session')
        sessions_count = int(request.form.get('sessions_count', 1))
        total_price = tutor.get('rate', 25) * sessions_count
        learning_goals = request.form.get('learning_goals', '')
        session_format = request.form.get('session_format', 'Online Video Call')
        student_email = request.form.get('email', '')
        student_phone = request.form.get('phone', '')

        booking_data = {
            "booking_id": booking_id,
            "tutor_id": tutor_id,
            "tutor_name": tutor['name'],
            "date": date,
            "time": time,
            "subject": subject,
            "session_type": session_type,
            "sessions_count": sessions_count,
            "total_price": total_price,
            "learning_goals": learning_goals,
            "session_format": session_format,
            "student_email": student_email,
            "student_phone": student_phone,
            "status": "pending_payment",
            "created_at": datetime.now().isoformat()
        }

        if dynamodb:
            try:
                bookings_table.put_item(Item=booking_data)
            except ClientError as e:
                logger.error(f"Error creating booking: {str(e)}")
                return "Booking failed. Please try again.", 500
        
        return redirect(url_for("payment", booking_id=booking_id))

    try:
        return render_template("booksession.html", tutor=tutor, tutor_id=tutor_id)
    except:
        return f"""
        <h1>Book Session with {tutor['name']}</h1>
        <form method="post">
            <p>Date: <input name="date" type="date" required></p>
            <p>Time: <input name="time" type="time" required></p>
            <p>Subject: <select name="subject" required>
                {''.join([f'<option value="{s}">{s}</option>' for s in tutor.get('subjects', [])])}
            </select></p>
            <p>Your Email: <input name="email" type="email" required></p>
            <p>Your Phone: <input name="phone" type="tel" required></p>
            <p>Learning Goals: <textarea name="learning_goals"></textarea></p>
            <p>Session Format: 
                <select name="session_format">
                    <option value="Online Video Call">Online Video Call</option>
                    <option value="In-Person">In-Person</option>
                </select>
            </p>
            <button type="submit">Book Session</button>
        </form>
        """

@app.route('/payment')
def payment():
    booking_id = request.args.get('booking_id')
    
    if dynamodb:
        try:
            response = bookings_table.get_item(Key={'booking_id': booking_id})
            booking = response.get('Item')
        except ClientError as e:
            logger.error(f"Error fetching booking: {str(e)}")
            booking = None
    else:
        booking = None
    
    if not booking:
        abort(404)
    
    try:
        return render_template("payment.html", booking=booking, booking_id=booking_id)
    except:
        return f"""
        <h1>Payment</h1>
        <p>Total Amount: ${booking['total_price']}</p>
        <p>Tutor: {booking['tutor_name']}</p>
        <p>Date: {booking['date']} at {booking['time']}</p>
        <form method='post' action='/process-payment'>
            <input name='booking_id' value='{booking_id}' type='hidden'>
            <p>Payment Method: 
                <select name='payment_method' required>
                    <option value="credit_card">Credit Card</option>
                    <option value="debit_card">Debit Card</option>
                    <option value="upi">UPI</option>
                    <option value="net_banking">Net Banking</option>
                </select>
            </p>
            <p>Email: <input name='email' type='email' value='{booking.get("student_email", "")}' required></p>
            <p>Phone: <input name='phone' type='tel' value='{booking.get("student_phone", "")}' required></p>
            <button type='submit'>Pay ${booking['total_price']}</button>
        </form>
        """

@app.route('/process-payment', methods=['POST'])
def process_payment():
    booking_id = request.form['booking_id']
    payment_method = request.form['payment_method']
    email = request.form['email']
    phone = request.form['phone']
    
    # Get booking details
    if dynamodb:
        try:
            response = bookings_table.get_item(Key={'booking_id': booking_id})
            booking = response.get('Item')
        except ClientError as e:
            logger.error(f"Error fetching booking: {str(e)}")
            abort(404)
    else:
        abort(404)
    
    if not booking:
        abort(404)
    
    # Create payment record
    payment_id = str(uuid.uuid4())
    payment_data = {
        "payment_id": payment_id,
        "booking_id": booking_id,
        "amount": booking["total_price"],
        "payment_method": payment_method,
        "status": "completed",
        "student_email": email,
        "student_phone": phone,
        "created_at": datetime.now().isoformat()
    }
    
    if dynamodb:
        try:
            # Save payment
            payments_table.put_item(Item=payment_data)
            
            # Update booking status
            bookings_table.update_item(
                Key={'booking_id': booking_id},
                UpdateExpression='SET #status = :status, payment_id = :payment_id',
                ExpressionAttributeNames={'#status': 'status'},
                ExpressionAttributeValues={
                    ':status': 'confirmed',
                    ':payment_id': payment_id
                }
            )
            
            # Create session record
            session_id = str(uuid.uuid4())
            sessions_table.put_item(Item={
                'session_id': session_id,
                'booking_id': booking_id,
                'tutor_id': booking['tutor_id'],
                'student_email': email,
                'date': booking['date'],
                'time': booking['time'],
                'subject': booking['subject'],
                'status': 'scheduled',
                'created_at': datetime.now().isoformat()
            })
            
        except ClientError as e:
            logger.error(f"Error processing payment: {str(e)}")
            return "Payment processing failed. Please try again.", 500
    
    # Send payment confirmation email
    payment_message = f"""
    Dear Student,

    Your payment has been successfully processed!

    Payment Details:
    - Payment ID: {payment_id}
    - Amount: ${booking['total_price']}
    - Payment Method: {payment_method.replace('_', ' ').title()}
    - Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

    Session Details:
    - Tutor: {booking['tutor_name']}
    - Subject: {booking['subject']}
    - Date & Time: {booking['date']} at {booking['time']}
    - Format: {booking.get('session_format', 'Online Video Call')}

    You will receive a reminder email 24 hours before your session.

    Thank you for choosing TutorMatch!

    Best regards,
    TutorMatch Team
    """
    
    send_notification(email, "Payment Confirmation - TutorMatch", payment_message, "payment_confirmation")
    
    # Send session reminder notification (this would typically be scheduled)
    session_reminder = f"""
    Dear Student,

    This is a reminder for your upcoming tutoring session:

    Session Details:
    - Tutor: {booking['tutor_name']}
    - Subject: {booking['subject']}
    - Date & Time: {booking['date']} at {booking['time']}
    - Format: {booking.get('session_format', 'Online Video Call')}

    Please be ready 5 minutes before the session starts.

    Best regards,
    TutorMatch Team
    """
    
    send_notification(email, "Session Reminder - TutorMatch", session_reminder, "session_reminder")
    
    return redirect(url_for('confirmation', booking_id=booking_id))

@app.route('/confirmation')
def confirmation():
    booking_id = request.args.get('booking_id')
    
    if dynamodb:
        try:
            response = bookings_table.get_item(Key={'booking_id': booking_id})
            booking = response.get('Item')
        except ClientError as e:
            logger.error(f"Error fetching booking: {str(e)}")
            booking = None
    else:
        booking = None
    
    if not booking:
        abort(404)
    
    try:
        return render_template("confirmation.html", booking=booking)
    except:
        return f"""
        <h1>Booking Confirmed!</h1>
        <div style="border: 2px solid green; padding: 20px; margin: 20px;">
            <h2>Session Details</h2>
            <p><strong>Booking ID:</strong> {booking['booking_id']}</p>
            <p><strong>Tutor:</strong> {booking['tutor_name']}</p>
            <p><strong>Subject:</strong> {booking['subject']}</p>
            <p><strong>Date & Time:</strong> {booking['date']} at {booking['time']}</p>
            <p><strong>Format:</strong> {booking.get('session_format', 'Online Video Call')}</p>
            <p><strong>Total Paid:</strong> ${booking['total_price']}</p>
            <p><strong>Status:</strong> {booking['status'].title()}</p>
        </div>
        <p>You will receive email notifications regarding your session.</p>
        <a href="/student-dashboard">Back to Dashboard</a>
        """

@app.route('/api/student-data')
def student_data():
    student_bookings = []
    student_payments = []
    notifications = []
    
    if dynamodb:
        try:
            # Get all bookings
            bookings_response = bookings_table.scan()
            for booking in bookings_response['Items']:
                student_bookings.append({
                    "id": booking["booking_id"],
                    "tutor_name": booking["tutor_name"],
                    "subject": booking["subject"],
                    "date": booking["date"],
                    "time": booking["time"],
                    "status": booking["status"],
                    "total_price": booking["total_price"],
                    "session_format": booking.get("session_format", "Online Video Call"),
                    "created_at": booking["created_at"]
                })
                
                if booking["status"] == "confirmed":
                    notifications.append({
                        "type": "success",
                        "title": "Session Confirmed",
                        "message": f"Your session with {booking['tutor_name']} is confirmed for {booking['date']} at {booking['time']}.",
                        "date": datetime.now().strftime("%Y-%m-%d")
                    })
            
            # Get all payments
            payments_response = payments_table.scan()
            for payment in payments_response['Items']:
                student_payments.append({
                    "id": payment["payment_id"],
                    "amount": payment["amount"],
                    "status": payment["status"],
                    "method": payment["payment_method"],
                    "date": payment["created_at"]
                })
                
        except ClientError as e:
            logger.error(f"Error fetching student data: {str(e)}")
    
    return jsonify({
        "bookings": student_bookings,
        "payments": student_payments,
        "notifications": notifications
    })

@app.route('/logout')
def logout():
    return redirect(url_for("homepage"))

@app.route('/health')
def health():
    tutors_count = 0
    if dynamodb:
        try:
            response = tutors_table.scan(Select='COUNT')
            tutors_count = response['Count']
        except ClientError as e:
            logger.error(f"Health check error: {str(e)}")
    
    return jsonify({
        "status": "healthy",
        "tutors_count": tutors_count,
        "aws_services": {
            "dynamodb": dynamodb is not None,
            "sns": sns_client is not None
        }
    })

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    app.run(host='0.0.0.0', port=port, debug=debug)
